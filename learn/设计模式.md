##设计模式

   在软件工程中，设计模式是对软件设计中普遍存在(反复出现)的各种问题，所提出的解决方案。
  
####设计模式的核心思想 - 封装变化 
   
   在实际开发中，不发生变化的代码可以说是不存在的。我们能做的只有将这个变化造成的影响**最小化**
   —— 将变与不变分离，确保变化的部分灵活，不变的部分稳定。这个过程，就叫“封装变化”。这样的代码，
   就是我们所谓的“稳健”的代码，它可以经得起变化的考验。而设计模式出现的意义，就是帮我们写出这样的
   代码。
   
   封装变比，封装的正是软件中那些不稳定的要素，它是一种防患于未然的行为 —— 提前抽离了变化，就为后续
   的扩展提供了无限的可能性，如此，我们才能做到在变化到来的时候从容不迫。   
      
![设计模式](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c737b7fdc46c47cfb6c09289cdf2e00f~tplv-k3u1fbpfcp-watermark.image?)

  ####设计模式
  * 简单工厂模式
  
     就是将创建对象的过程单独封装。
     
  ```javascript
     function User(name,age,career,work) {
            this.name = name;
            this.age = age;
            this.career = career;
            this.work = work;
     }
     
     function Factory(name,age,career) {
         let work;
         switch (career) {
              case 'coder':
                  work = ['写代码','写系统','修Bug'];
                  break;
              case  'product manager':
                  work = ['订会议室','写PRO','催更'];
                  break;
              default:
                  break;
         }
         
         return new User(name,age,career,work);
     }
```       

 * 抽象工厂方法  
   
   是围绕一个超级工厂创建其他工厂。
   
   四个关键角色
    * 抽象工厂(抽象类，它不能被用于生成具体实例)  
    * 具体工厂(用于生成产品族里的一个具体的产品)
    * 抽象产品(抽象类，他不能被用于生成具体实例)
    * 具体产品(用于生成产品族里的一个具体的产品所依赖的更细粒度的产品)
    
  ```javascript
      class MobilePhoneFactory {
    
           createOs(){
               throw  new Error('抽象工厂方法不允许直接返回,你需要将我重写!');
           } 
      }
      
      class FakeStartFactory extends MobilePhoneFactory{
          
          createOs(){
                return new AndroidOs();
          }

      }
      
      class OS {
          constructor(){
               // throw  new Error('抽象产品方法不允许直接返回,你需要将我重写!')
          }
      }
      
      class AndroidOs extends OS{
          constructor(){
               super();
               console.log('我会用安卓的方式去操作硬件')
          }
      }
      
      const myPhone = new FakeStartFactory();
      const myOs = myPhone.createOs();  
```
   * 单例模式
   
     保证一个类仅有一个实例，并提供一个访问它的全局访问点。
   ```javascript
    class SingleDog {
        show(){
            console.log('我是一个单例对象');
        }
        static getInstance(){
            if(!SingleDog.instance){
                SingleDog.instance = new SingleDog();
            }
            
            return SingleDog.instance;
        }
    }
    
    const s1 = SingleDog.getInstance();
    const s2 = SingleDog.getInstance();
    console.log(s1 === s2);//true
    
    //闭包实现
    SingleDog.getInstance =(function() {
        let instance = null;
        return function() {
            if(!instance){
                instance = new SingleDog();
            }
            return instance;
        }
    })()
```  
 * 实现一个Storage
 
   (要求: 使该对象为单例，基于localStorage进行封装，实现方法setItem(key,value) 和getItem(key))。
   
 ```javascript
    class Storage {
        static getInstance(){
            if(!Storage.instance){
                Storage.instance = new Storage();
            }
            return  Storage.instance;
        }
        
        getItem(key){
            return  localStorage.getItem(key);
        }
        
        setItem(key,value){
            return localStorage.setItem(key,value);
        }
    }
    
    const storage1 = Storage.getInstance();
    const storage2 = Storage.getInstance();
    
    storage1.setItem('name', '李雷');
    // 李雷
    storage1.getItem('name');
    // 也是李雷
    storage2.getItem('name');
    
    // 返回true
    console.log(storage1 === storage2);
    
    /************************闭包实现***************************/
    
    function StorageBase() {
      
    }
    
    StorageBase.prototype.setItem = function(key,value) {
         return localStorage.setItem(key,value);
    };
   
    StorageBase.prototype.getItem = function(key) {
        return localStorage.getItem(key)
    };
    
    const StorageOther = (function() {
         let instance = null;
         return function() {
              if(!instance){
                  instance = new StorageBase();
              }
              return  instance;
         }
    })();
    
    const s1 = new StorageOther();
    const s2 = new StorageOther();
    
    s1.setItem('name', '李雷');
    // 李雷
    s1.getItem('name');
    // 也是李雷
    s2.getItem('name');
    
    // 返回true
    console.log(s1 === s2);
```  

  * 实现一个全局的模态框
    
    (要求：实现一个全局唯一的Modal弹框)
   
```html
   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="UTF-8">
       <title>Title</title>
       <style>
            #modal{
                height: 200px;
                width: 200px;
                line-height: 200px;
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%,-50%);
                border: 1px solid #000;
                text-align: center;
            } 
       </style>
   </head>
   <body>
      <button id="open">打开弹框</button>
      <button id="close">关闭弹框</button>
   <script>
        const Modal = (function() {
           let modal = null;
           return function() {
             if(!modal){
                 modal  = document.createElement('div');
                 modal.innerHTML = '我是一个全网唯一的Modal';
                 modal.id = 'modal';
                 modal.style.display = 'none';
                 document.body.appendChild(modal);
             }
             return modal;
           }
        })();
        
        document.querySelector('#open').addEventListener('click',function() {
               const modal =  new Modal();
               modal.style.display = 'block';
        });
        
        document.querySelector('#close').addEventListener('click',function() {
               const modal = new Modal();
               if(modal){
                   modal.style.display = 'none';
               }
        })
   </script>
   </body>
   </html>
```
   
   * 装饰器模式      
     
     对已有功能进行扩展，只关心扩展出来的那部分新功能如何实现。
     
```javascript
    //定义打开按钮
    class OpenButton {
        //点击后打开弹框(旧逻辑)
        onClick(){
            const modal = new Modal();
            modal.style.display = 'block';
        }
    }
    
    // 定义按钮对应的装饰器
    class Decorator {
        constructor(open_button){
            this.open_button = open_button;
        }
        
        onClick(){
            this.open_button.onClick();
            //包装了一层装饰器
            this.changeButtonStatus();
        }
        
        changeButtonStatus(){
            this.changeButtonText();
            this.disableButton();
        }
        
        disableButton(){
            const btn = document.getElementById('open');
            btn.setAttribute('disable',true);
        }
        
        changeButtonText(){
            const btn = document.getElementById('open');
            btn.innerText = '快去登录';
        }
        
    }
    
    const openButton = new OpenButton();
    const decorator = new Decorator(openButton);
    decorator.onClick();
```     
  * 适配器模式(好用)  
     
     把一个类的接口变换成客户端所期待的另一种接口,可以帮助我们解决不兼容问题。
```javascript
    export  default  class HttpUtils {
        static get(url){
            return new Promise((resolve, reject) =>{
                 fetch(url)
                    .then(response => response.json())
                    .then(result => {
                        resolve(result);
                    }).catch(error =>{
                        reject(error);
                    })
            })
        }
    }
    
    //使用发送get请求
    async function  get(url) {
          const getResponse = await HttpUtils.get(url);
    }

    //XMLHttpRequest的方法
    function ajax(type,url,data,success,failed) {
       let xhr = null;
       if(window.XMLHttpRequest){
           xhr = new XMLHttpRequest();
       }else{
           xhr = new ActiveXObject('Microsoft.XMLHTTP');
       }
       
       type = type.toUpperCase();
       
       if(type === 'GET'){
           if(data){
               xhr.open('GET', url + '?' + data,true)
           }
           xhr.send();
       }
       
       xhr.onreadystatechange = function() {
            if(xhr.readStats === 4 ){
                if(xhr.state === 200){
                    success(xhr.responseText);
                }else{
                    if(failed){
                        failed(xhr.status);
                    }
                }
            }
       }
    }
    
    //使用ajax发送
    ajax('get','/rest/get','12',function(data) {
        console.log(data);
    },function(error) {
        console.error(error);
    })
    
    //ajax适配器函数,入参与旧接口保持一致
    async function AjaxAdapter(type,url,data,success,failed) {
        type = type.toUpperCase();
        let result;
        try{
            if(type === 'GET'){
                result = await HttpUtils.get(url) || {};
            }
            
            result.statusCode === 1 && success? success(result) : failed(result.statusCode);
        }catch (error) {
            if(failed){
                failed(error.statusCode);
            }
        }
    }
    
    //用适配器适配就的ajax方法
    async function ajaxNew(type,url,data,success,failed) {
         await  AjaxAdapter(type,url,data,success,failed)
    }
```
